- name: Get the home directory
  user:
    name: "{{ ansible_user }}"
  register: userinfo

- name: Get the Ansible user's SSH key
  slurp:
    src: "{{ userinfo.home }}/.ssh/id_rsa.pub"
  become: no
  register: key

# Gogs thinks the key exists if the title matches an existing key.
# So we hash the key to add to the title.
- name: Get a key checksum
  set_fact:
    key_md5: "{{ key['content'] | b64decode | md5 }}"

- name: Set up deploy keys on gogs
  uri:
    url: https://git.megaphonetech.com/api/v1/repos/{{ item.item.value.git_repo_owner + '/' + item.item.value.git_repo_name }}/keys
    method: POST
    body_format: json
    body:
      title: "{{ ansible_user + '@' + inventory_hostname_short + ' ' + key_md5 }}"
      key: "{{ key['content'] | b64decode }}"
    headers:
      Authorization: token {{ lookup('passwordstore', 'megaphone/gogs/api') }}
  register: gogs_result
  changed_when: gogs_result.status == 201
  failed_when: gogs_result.status != 201 and not (gogs_result.json is defined and gogs_result.json.message is defined and gogs_result.json.message | search("public key already exists"))

- name: clone an existing site
  git:
    repo: "{{ item.item.value.git_repo_url }}"
    dest: "{{ item.item.value.gitroot }}"
    version: master
    umask: "0007"
    track_submodules: yes

- name: Create CiviCRM uploads folder
  file:
    path: "{{ item.item.value.civicrm_settings_php_path }}"
    state: directory
  when: item.item.value.civicrm == 'Yes'

- name: Add civicrm.settings.php
  template:
    src: templates/civicrm.settings.j2
    dest: "{{ item.item.value.civicrm_settings_php_path }}/civicrm.settings.php"
    owner: "{{ ansible_user }}"
    group: "{{ item.item.value.run_as_user }}"
    mode: 0660

- name: Create wp-config.php
  shell: |
    wp config create --dbname={{ item.item.value.cms_db_name }} --dbuser={{ item.item.value.db_user }} --dbpass={{ lookup('passwordstore', item.item.value.client + '/' + hostname + '/' + item.item.value.bare_url + '/mysql') }} {% if item.item.value.cms_table_prefix|default('blank', True) != 'blank' %}--dbprefix={{ item.item.value.cms_table_prefix}}{% endif %} --path={{ item.item.value.webroot }} --extra-php <<PHP
    define( 'WP_SITEURL', '{{ item.item.value.primary_url }}' );
  args:
    creates: "{{ item.item.value.webroot }}/wp-config.php"

# MySQL restore
# This is so fucking ugly. Newer versions of borgbackup eliminate the need for piping to tail and cut, but we probably won't have them until Debian 10 ships.
- name: Get the latest backup archive name
  shell: borg list --remote-path /usr/local/bin/borg1/borg1 8139@usw-s008.rsync.net:{{ item.item.value.client + '-' + item.item.value.canonical_hostname }} | tail -n1 | cut -f 1 -d ' '
  environment:
    BORG_PASSPHRASE: "{{ lookup('passwordstore', item.item.value.client + '/' + item.item.value.canonical_hostname + '/borg/remote') }}"
  register: archive_name
  changed_when: false

- name: Create sql-dumps folder
  file:
    path: "{{ item.item.value.webroot }}/../sql-dumps"
    state: directory

- name: Download the latest copy of the database
  shell: borg extract --strip-components 4 --remote-path /usr/local/bin/borg1/borg1 8139@usw-s008.rsync.net:{{ item.item.value.client + '-' + item.item.value.canonical_hostname }}::{{ archive_name.stdout }} var/backups/mysql/sqldump
  args:
    chdir: "{{ item.item.value.webroot }}/../sql-dumps"
  environment:
    BORG_PASSPHRASE: "{{ lookup('passwordstore', item.item.value.client + '/' + item.item.value.canonical_hostname + '/borg/remote') }}"
